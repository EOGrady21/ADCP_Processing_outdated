library(oce)

####read data####

adp <- read.adp("M1840000.000", latitude = 48, longitude =45 ) #insert lat and lon from mooring logs

#read data in again and leave in raw to compare when processing
adp_raw <- read.adp("M1840000.000")


#####load initial variables####
v <- adp[['v']]
pressure <- adp[['pressure']]
lat <- adp[['latitude']] 
lon <- adp[['longitude']]
depth <- adp[['depth']]

####Create flags for data outside bounds
#threshold based on BIO standards, 
#flag (FFFF) :
#minimum percent good, flag <- PG1 +PG4 < 25 |
#maximum error velocity, flag <- ERRV > 0.46 m/sec | 
#surface contamination, flag <- depth > rmax, where rmax =  (D*cos(beamAngle)) 

# minimum percent good 
# beams 1 + 4 > 25, represents percent good of 3 beam solutions plus 4 beam solutions
# source: BIO scientists (documentation:)
#threshold of error velocities
# flag any data with error velocities higher than 1.5 ft/sec or 0.46 m/sec 
#subject to change depending on a variety of factors including instrument frequency, water mode, etc
#source: USGS, documentation: https://water.usgs.gov/admin/memo/SW/OSW.2002.03.htm
#surface contamination
#maximum acceptable data range avoiding surface contamination is based
#on the beam angle of intsrument and depth of deployment
#[ source :RDI primer for ADCP data]

#depth threshold

#beam angle translated to radians
deg2rad <- function(deg) {(deg * pi) / (180)}


#RDI primer equation for maximum acceptable data range
rmax <- depth *(cos(deg2rad(adp[['beamAngle']])))

#create matrix of maximum acceptable depth
r <- matrix(rmax, ncol=length(adp[['distance']]), nrow=length(rmax))


#create matrix of distance (adp to surface)
dist <- adp[['distance']]
d <- t(matrix(dist, ncol = length(adp[['time']]), nrow = length(dist)))

#read in pg per beam
g <- adp[['g', "numeric"]]

#combine beam 1 and 4
lowpg <- g[,,1]+g[,,4]

#extract error velocities
ERRV <- adp[['v']][,,4]

#create array of flagged values based on low percent good, high error velocity or surface contamination
dim = dim(v)
flag <- array(FALSE, dim= dim)
for (i in 1:4)
  flag[,,i] <- (lowpg<25) | (abs(ERRV) > 0.46) | r < d


#insert and handle flags
adp[['vFlag']] <- flag
adp <- handleFlags(adp)
plot(adp, which = 1)


####trim time when transducer was out of water (pre and post deployment)
#plot start of time series
plot(subset(adp, time < mean(range(adp[['time']]))-10e6), which = 1)
#plot end of time series
plot(subset(adp, time > mean(range(adp[['time']]))+10e6), which = 1)

#check mooring logs for exact time to deployment / retrieval

#instrument time in numeric POSIXct
SYTM <- as.numeric(adp[['time']])

#insert bottom time from log sheet
t_first <- as.POSIXct("2013-07-04 12:21:00", tz = 'UTC')
t_first <- as.numeric(t_first)

t <- adp[['time', "numeric"]]
t <- as.numeric(t, tz = 'UTC')

#cut off data before bottom deployment
adp[['v']][t < t_first] <- NA
     

#retrieval time
t_final <- as.POSIXct("2014-07-07 11:28:00, tz = 'UTC")
t_final <- as.numeric(t_final)

#cut off data after recovery
adp[['v']][t > t_final] <- NA
      

#plot again to visually check data cut off
#plot start of time series
plot(subset(adp, time < mean(range(adp[['time']]))-10e6), which = 1)
#plot end of time series
plot(subset(adp, time > mean(range(adp[['time']]))+10e6), which = 1)


#### pressure to depth####
  # pressure data from ADCP is converted into depth of seawater using swDepth function,
  # depth data can also be acessed by oce package directly, although this data is not corrected for specific temperature and pressure. 
  #Depth is plotted over time series to check for drift or bad data from movement of mooring or transducer
  # Depth is averaged over entire deployment.
  

#using swDepth
d <- swDepth(pressure, latitude = lat, eos = getOption("oceEOS", default = "gsw"))

#plot subset, visually check for drift
plot(subset(depth, depth >0))

#average depth data
meanDepth_oce <- adp[['depthMean']] #calculated by oce / instrument

meanDepth_trimmed <- mean(depth) #calculated after trimming surafce/erroneous data

#optional if data is drifting
  #depth <- subset(depth, depth < meanDepth+2)


####Transducer depth calculations using mooring separation or oce script####
#subtract mooring separation distance (source: log sheet, units = m)
mooringSep <- 3
transDepth <- meanDepth - mooringSep

#compare to oce output
transducerDepth <- adp[['transducerDepth']]

####Bin 1 calculations####
  #distance to bin 1 is extracted from adp class file in oce, 
  #transducer depth is subtracted to find the mean depth of the first bin

#distance to bin 1
distanceToBin1 <- adp[['bin1Distance']]

#bin 1 distance - transducer depth
bin1Depth <- distanceToBin1 - transducerDepth


####Correction for magnetic variation over time series###
   #magnetic declination is calculated and applied to data series
   #method 1 shows magnetic declination averaged between start and end dates
   #method 2 shows magnetic declination calculated as a time series
   

#start and end times
startTime <- adp[['time']][1]
endTime <- max(adp[['time']])

#method 1
  #magnetic declination calculation at start and end of deployment using oce
  mStart <- magneticField(lon, lat, startTime)
  mEnd <- magneticField(lon, lat, endTime)

  #averaging start and end declinations
  mAvg <- round(mean(c(mStart$declination, mEnd$declination)), digits = 2)

  #applying declination to velocity data
adp <- oceSetMetadata(adp, 'oceCoordinate', 'xyz')
adp <- xyzToEnu(adp, declination = mAvg)


#Method 2
#
#
#
#



####data output####
#extract velocity components
EWCT <- adp[['v']][,,1] #U
NSCT <- adp[['v']][,,2] #V
VCSP <- adp[['v']][,,3] #vertical velocity
ERRV <- adp[['v']][,,4] #error velocity

#percent good
PG1 <- adp[['g', 'numeric']][,,1]
PG2 <- adp[['g', 'numeric']][,,2]
PG3 <- adp[['g', 'numeric']][,,3]
PG4 <- adp[['g', 'numeric']][,,4]

#flags on velocity values
flag
#adp@metadata$flags$FFFF

#onboard sensor data #correct variable names?
TEMP <- adp[['temperature']]  #temperature
BEAM <- adp[['a']]            #average echo intensity
PITCH <- adp[['pitch']]       #pitch
ROLL <- adp[['roll']]         #roll


