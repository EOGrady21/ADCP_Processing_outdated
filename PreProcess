library(oce)

####read data####

adp <- read.adp("M1840000.000", latitude = 48, longitude =45 ) #insert lat and lon from mooring logs

#read data in again and leave in raw to compare when processing
adp_raw <- read.adp("M1840000.000")


#####load initial variables####
v <- adp[['v']]
pressure <- adp[['pressure']]
lat <- adp[['latitude']] 
lon <- adp[['longitude']]

####trim time when transducer was out of water (pre and post deployment)
#plot start of time series
plot(subset(adp, time < mean(range(adp[['time']]))-10e6), which = 1)
#plot end of time series
plot(subset(adp, time > mean(range(adp[['time']]))+10e6), which = 1)

#check mooring logs for exact time to deployment / retrieval

#instrument time in numeric POSIXct
SYTM <- as.numeric(adp[['time']])

#insert bottom time from log sheet
t_first <- as.POSIXct("2013-07-04 12:21:00", tz = 'UTC')
t_first <- as.numeric(t_first)

t <- adp[['time', "numeric"]]
t <- as.numeric(t, tz = 'UTC')

#cut off data before bottom deployment
adp[['v']][t < t_first] <- NA
     

#retrieval time
t_final <- as.POSIXct("2014-07-07 11:28:00, tz = 'UTC")
t_final <- as.numeric(t_final)

#cut off data after recovery
adp[['v']][t > t_final] <- NA
      

#plot again to visually check data cut off
#plot start of time series
plot(subset(adp, time < mean(range(adp[['time']]))-10e6), which = 1)
#plot end of time series
plot(subset(adp, time > mean(range(adp[['time']]))+10e6), which = 1)


#### microcat pressure to depth####
  # pressure data from ADCP is converted into depth of seawater using swDepth function,
  # depth data can also be acessed by oce package directly, although this data is not corrected for specific temperature and pressure. 
  # pre and post deployment data is removed based on depth < 0 (above water surface).
  #Depth is plotted over time series to check for drift or bad data from movement of mooring or transducer
  # Depth is averaged over entire deployment.
  
d <- adp[['depth']]

#using swDepth
d <- swDepth(pressure, latitude = lat, eos = getOption("oceEOS", default = "gsw"))

#plot subset, visually check for drift
plot(subset(d, d >0))

#trim depth data
depth <- subset(d, d>10)      #subsetting data to include only depths below 10m, avoiding data collected while mooring was in transit
adp[['v']][d< 10 ] <- NA        #setting velocity data above 10m to NA

#average depth data
meanDepth_oce <- adp[['depthMean']] #calculated by oce / instrument

meanDepth_trimmed <- mean(depth) #calculated after trimming surafce/erroneous data

#optional if data is drifting
  #depth <- subset(depth, depth < meanDepth+2)


####Transducer depth calculations using mooring separation or oce script####
#subtract mooring separation distance (source: log sheet, units = m)
mooringSep <- 3
transDepth <- meanDepth - mooringSep

#compare to oce output
transducerDepth <- adp[['transducerDepth']]

####Bin 1 calculations####
  #distance to bin 1 is extracted from adp class file in oce, 
  #transducer depth is subtracted to find the mean depth of the first bin

#distance to bin 1
distanceToBin1 <- adp[['bin1Distance']]

#bin 1 distance - transducer depth
bin1Depth <- distanceToBin1 - transducerDepth

####Create flags for data outside bounds
#threshold based on BIO standards, 
#flag (FFFF) : minimum percent good, flag <- PG1 +PG4 < 25 |
#maximum error velocity, flag <- ERRV > 0.46 m/sec | 
# surface contamination, flag <- depth > rmax (D*cos(beamAngle)) [ source :RDI primer for ADCP data]


    #read in pg per beam
      g <- adp[['g', "numeric"]]

    #combine beam 1 and 4
      lowpg <- g[,,1]+g[,,4]
      
      #extract error velocities
      ERRV <- adp[['v']][,,4]
      
      # set maximum error velocity
      higherrv <- abs(ERRV) > 0.46 
      
      #find maximum range of acceptable data, equation from RDI Primer for ADCP data
      #STILL HAVING ISSUES WITH THIS FLAG
      rmax <- d *cos(adp[['beamAngle']])
      

    #create flag array
       dim <- dim(v)
       flag <- array(FALSE, dim= dim)
       for (i in 1:4)
          flag[,,i] <- (lowpg<25) | (ERRV > 0.46) | (d > rmax)| (d < 0 )

    #insert  flag into adp object
      adp@metadata$flags[["FFFF"]] <- flag




####Correction for magnetic variation over time series###
   #magnetic declination is calculated and applied to data series
   #method 1 shows magnetic declination averaged between start and end dates
   #method 2 shows magnetic declination calculated as a time series
   

#start and end times
startTime <- adp[['time']][1]
endTime <- max(adp[['time']])

#method 1
  #magnetic declination calculation at start and end of deployment using oce
  mStart <- magneticField(lon, lat, startTime)
  mEnd <- magneticField(lon, lat, endTime)

  #averaging start and end declinations
  mAvg <- round(mean(c(mStart$declination, mEnd$declination)), digits = 2)

  #applying declination to velocity data
adp <- oceSetMetadata(adp, 'oceCoordinate', 'xyz')
adp <- xyzToEnu(adp, declination = mAvg)


#Method 2
#
#
#
#


####Thresholding data to prevent spikes or bad data with interference####
  #thresholding is done by setting minimum percent good on data
       # minimum of 25 % good on beams 1 and 4 combined, represents percent good of 3 beam solutions plus 4 beam solutions
       # source: BIO scientists (documentation:)
  #threshold of error velocities
        # null/ flag any data with error velocities higher than 1.5 ft/sec or 0.46 m/sec depending on a variety of factors
        #source: USGS, documentation: https://water.usgs.gov/admin/memo/SW/OSW.2002.03.htm

#plot percent good pings
plot(adp, which = c(70:73), decimate = FALSE)

#read in percent good as integer (out of raw format)
g <- adp[['g', "numeric"]]

#combine beam 1 and 4
lowpg <- g[,,1]+g[,,4]


#null (NA) velocity  values below PG1 + PG4 = 25
adp[['v']][lowpg < 25] <- NA


#visually check how much data has been nulled
plot(adp, which = 1)
plot(adp_raw, which = 1)


#null error velocities >1.5 ft/sec or 0.46 m/sec source:https://water.usgs.gov/admin/memo/SW/OSW.2002.03.htm


ERRV <- adp[['v']][,,4]
higherrv <- abs(ERRV) > 0.46 

#null (NA) velocity values with error velocity >0.46 m/sec
adp[['v']][higherrv] <- NA  

#visually check how much data has been nulled
plot(adp, which = 4)
plot(adp_raw, which = 4)



####data output####
#extract velocity components
EWCT <- adp[['v']][,,1] #U
NSCT <- adp[['v']][,,2] #V
VCSP <- adp[['v']][,,3] #vertical velocity
ERRV <- adp[['v']][,,4] #error velocity

#percent good
PG1 <- adp[['g', 'numeric']][,,1]
PG2 <- adp[['g', 'numeric']][,,2]
PG3 <- adp[['g', 'numeric']][,,3]
PG4 <- adp[['g', 'numeric']][,,4]

#flags on velocity values
flag
#adp@metadata$flags$FFFF

#onboard sensor data #correct variable names?
TEMP <- adp[['temperature']]  #temperature
BEAM <- adp[['a']]            #average echo intensity
PITCH <- adp[['pitch']]       #pitch
ROLL <- adp[['roll']]         #roll


